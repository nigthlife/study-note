
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>ast --- 抽象语法树 &#8212; Python 3.8.16 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.8.16 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="symtable ——访问编译器的符号表" href="symtable.html" />
    <link rel="prev" title="parser --- 访问 Python 解析树" href="parser.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/ast.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code> --- 抽象语法树</a><ul>
<li><a class="reference internal" href="#node-classes">节点类</a></li>
<li><a class="reference internal" href="#abstract-grammar">抽象文法</a></li>
<li><a class="reference internal" href="#ast-helpers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code> 中的辅助函数</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="parser.html"
                        title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code> --- 访问 Python 解析树</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="symtable.html"
                        title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symtable</span></code> ——访问编译器的符号表</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/library/ast.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="symtable.html" title="symtable ——访问编译器的符号表"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="parser.html" title="parser --- 访问 Python 解析树"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.8.16 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="language.html" accesskey="U">Python 语言服务</a> &#187;</li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-ast">
<span id="ast-abstract-syntax-trees"></span><h1><a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> --- 抽象语法树<a class="headerlink" href="#module-ast" title="永久链接至标题">¶</a></h1>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/ast.py">Lib/ast.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 模块帮助 Python 程序处理 Python 语法的抽象语法树。抽象语法或许会随着 Python 的更新发布而改变；该模块能够帮助理解当前语法在编程层面的样貌。</p>
<p>抽象语法树可通过将 <code class="xref py py-data docutils literal notranslate"><span class="pre">ast.PyCF_ONLY_AST</span></code> 作为旗标传递给 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 内置函数来生成，或是使用此模块中提供的 <a class="reference internal" href="#ast.parse" title="ast.parse"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse()</span></code></a> 辅助函数。返回结果将是一个对象树，，其中的类都继承自 <a class="reference internal" href="#ast.AST" title="ast.AST"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.AST</span></code></a>。抽象语法树可被内置的 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 函数编译为一个 Python 代码对象。</p>
<section id="node-classes">
<h2>节点类<a class="headerlink" href="#node-classes" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="ast.AST">
<em class="property">class </em><code class="sig-prename descclassname">ast.</code><code class="sig-name descname">AST</code><a class="headerlink" href="#ast.AST" title="永久链接至目标">¶</a></dt>
<dd><p>这是所有 AST 节点类的基类。实际上，这些节点类派生自 <code class="file docutils literal notranslate"><span class="pre">Parser/Python.asdl</span></code> 文件，其中定义的语法树示例 <a class="reference internal" href="#abstract-grammar"><span class="std std-ref">如下</span></a>。它们在 C 语言模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_ast</span></code> 中定义，并被导出至 <a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 模块。</p>
<p>抽象语法定义的每个左侧符号(比方说，  <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.stmt</span></code> 或者 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.expr</span></code>)定义了一个类。另外，在抽象语法定义的右侧，对每一个构造器也定义了一个类；这些类继承自树左侧的类。比如，<code class="xref py py-class docutils literal notranslate"><span class="pre">ast.BinOp</span></code> 继承自 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.expr</span></code>。对于多分支产生式(也就是&quot;和规则&quot;)，树右侧的类是抽象的；只有特定构造器结点的实例能被构造。</p>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><dl class="attribute">
<dt id="ast.AST._fields">
<code class="sig-name descname">_fields</code><a class="headerlink" href="#ast.AST._fields" title="永久链接至目标">¶</a></dt>
<dd><p>每个具体类都有个属性 <a class="reference internal" href="#ast.AST._fields" title="ast.AST._fields"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields</span></code></a>, 用来给出所有子节点的名字。</p>
<p>每个具体类的实例对它每个子节点都有一个属性，对应类型如文法中所定义。比如，<code class="xref py py-class docutils literal notranslate"><span class="pre">ast.BinOp</span></code> 的实例有个属性 <code class="xref py py-attr docutils literal notranslate"><span class="pre">left</span></code>，类型是 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.expr</span></code>.</p>
<p>如果这些属性在文法中标记为可选（使用问号），对应值可能会是 <code class="docutils literal notranslate"><span class="pre">None</span></code>。如果这些属性有零或多个（用星号标记），对应值会用Python的列表来表示。所有可能的属性必须在用 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 编译得到AST时给出，且是有效的值。</p>
</dd></dl>

<dl class="attribute">
<dt id="ast.AST.lineno">
<code class="sig-name descname">lineno</code><a class="headerlink" href="#ast.AST.lineno" title="永久链接至目标">¶</a></dt>
<dt id="ast.AST.col_offset">
<code class="sig-name descname">col_offset</code><a class="headerlink" href="#ast.AST.col_offset" title="永久链接至目标">¶</a></dt>
<dt id="ast.AST.end_lineno">
<code class="sig-name descname">end_lineno</code><a class="headerlink" href="#ast.AST.end_lineno" title="永久链接至目标">¶</a></dt>
<dt id="ast.AST.end_col_offset">
<code class="sig-name descname">end_col_offset</code><a class="headerlink" href="#ast.AST.end_col_offset" title="永久链接至目标">¶</a></dt>
<dd><p>Instances of <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.expr</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.stmt</span></code> subclasses have
<a class="reference internal" href="#ast.AST.lineno" title="ast.AST.lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code></a>, <a class="reference internal" href="#ast.AST.col_offset" title="ast.AST.col_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code></a>, <a class="reference internal" href="#ast.AST.lineno" title="ast.AST.lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code></a>, and <a class="reference internal" href="#ast.AST.col_offset" title="ast.AST.col_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code></a>
attributes.  The <a class="reference internal" href="#ast.AST.lineno" title="ast.AST.lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code></a> and <a class="reference internal" href="#ast.AST.end_lineno" title="ast.AST.end_lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">end_lineno</span></code></a> are the first and
last line numbers of source text span (1-indexed so the first line is line 1)
and the <a class="reference internal" href="#ast.AST.col_offset" title="ast.AST.col_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code></a> and <a class="reference internal" href="#ast.AST.end_col_offset" title="ast.AST.end_col_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">end_col_offset</span></code></a> are the corresponding
UTF-8 byte offsets of the first and last tokens that generated the node.
The UTF-8 offset is recorded because the parser uses UTF-8 internally.</p>
<p>注意编译器不需要结束位置，所以结束位置是可选的。结束偏移在最后一个符号*之后*，例如你可以通过 <code class="docutils literal notranslate"><span class="pre">source_line[node.col_offset</span> <span class="pre">:</span> <span class="pre">node.end_col_offset]</span></code> 获得一个单行表达式节点的源码片段。</p>
</dd></dl>

<p>一个类的构造器 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.T</span></code> 像下面这样parse它的参数。</p>
<ul class="simple">
<li><p>如果有位置参数，它们必须和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">T._fields</span></code> 中的元素一样多；他们会像这些名字的属性一样被赋值。</p></li>
<li><p>如果有关键字参数，它们必须被设为和给定值同名的属性。</p></li>
</ul>
<p>比方说，要创建和填充节点 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.UnaryOp</span></code>，你得用</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">node</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">UnaryOp</span><span class="p">()</span>
<span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">USub</span><span class="p">()</span>
<span class="n">node</span><span class="o">.</span><span class="n">operand</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span>
<span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">lineno</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">col_offset</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">node</span><span class="o">.</span><span class="n">lineno</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">node</span><span class="o">.</span><span class="n">col_offset</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>或者更紧凑点</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">node</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">UnaryOp</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">USub</span><span class="p">(),</span> <span class="n">ast</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">lineno</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">col_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                   <span class="n">lineno</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">col_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>类 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Constant</span></code> 现在用于所有常量。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.8 版后已移除: </span>Old classes <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Num</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Bytes</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">ast.NameConstant</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Ellipsis</span></code> are still available,
but they will be removed in future Python releases.  In the meanwhile,
instantiating them will return an instance of a different class.</p>
</div>
</section>
<section id="abstract-grammar">
<span id="id1"></span><h2>抽象文法<a class="headerlink" href="#abstract-grammar" title="永久链接至标题">¶</a></h2>
<p>抽象文法目前定义如下</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-- ASDL&#39;s 5 builtin types are:
-- identifier, int, string, object, constant

module Python
{
    mod = Module(stmt* body, type_ignore *type_ignores)
        | Interactive(stmt* body)
        | Expression(expr body)
        | FunctionType(expr* argtypes, expr returns)

        -- not really an actual node but useful in Jython&#39;s typesystem.
        | Suite(stmt* body)

    stmt = FunctionDef(identifier name, arguments args,
                       stmt* body, expr* decorator_list, expr? returns,
                       string? type_comment)
          | AsyncFunctionDef(identifier name, arguments args,
                             stmt* body, expr* decorator_list, expr? returns,
                             string? type_comment)

          | ClassDef(identifier name,
             expr* bases,
             keyword* keywords,
             stmt* body,
             expr* decorator_list)
          | Return(expr? value)

          | Delete(expr* targets)
          | Assign(expr* targets, expr value, string? type_comment)
          | AugAssign(expr target, operator op, expr value)
          -- &#39;simple&#39; indicates that we annotate simple name without parens
          | AnnAssign(expr target, expr annotation, expr? value, int simple)

          -- use &#39;orelse&#39; because else is a keyword in target languages
          | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
          | While(expr test, stmt* body, stmt* orelse)
          | If(expr test, stmt* body, stmt* orelse)
          | With(withitem* items, stmt* body, string? type_comment)
          | AsyncWith(withitem* items, stmt* body, string? type_comment)

          | Raise(expr? exc, expr? cause)
          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
          | Assert(expr test, expr? msg)

          | Import(alias* names)
          | ImportFrom(identifier? module, alias* names, int? level)

          | Global(identifier* names)
          | Nonlocal(identifier* names)
          | Expr(expr value)
          | Pass | Break | Continue

          -- XXX Jython will be different
          -- col_offset is the byte offset in the utf8 string the parser uses
          attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

          -- BoolOp() can use left &amp; right?
    expr = BoolOp(boolop op, expr* values)
         | NamedExpr(expr target, expr value)
         | BinOp(expr left, operator op, expr right)
         | UnaryOp(unaryop op, expr operand)
         | Lambda(arguments args, expr body)
         | IfExp(expr test, expr body, expr orelse)
         | Dict(expr* keys, expr* values)
         | Set(expr* elts)
         | ListComp(expr elt, comprehension* generators)
         | SetComp(expr elt, comprehension* generators)
         | DictComp(expr key, expr value, comprehension* generators)
         | GeneratorExp(expr elt, comprehension* generators)
         -- the grammar constrains where yield expressions can occur
         | Await(expr value)
         | Yield(expr? value)
         | YieldFrom(expr value)
         -- need sequences for compare to distinguish between
         -- x &lt; 4 &lt; 3 and (x &lt; 4) &lt; 3
         | Compare(expr left, cmpop* ops, expr* comparators)
         | Call(expr func, expr* args, keyword* keywords)
         | FormattedValue(expr value, int? conversion, expr? format_spec)
         | JoinedStr(expr* values)
         | Constant(constant value, string? kind)

         -- the following expression can appear in assignment context
         | Attribute(expr value, identifier attr, expr_context ctx)
         | Subscript(expr value, slice slice, expr_context ctx)
         | Starred(expr value, expr_context ctx)
         | Name(identifier id, expr_context ctx)
         | List(expr* elts, expr_context ctx)
         | Tuple(expr* elts, expr_context ctx)

          -- col_offset is the byte offset in the utf8 string the parser uses
          attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    expr_context = Load | Store | Del | AugLoad | AugStore | Param

    slice = Slice(expr? lower, expr? upper, expr? step)
          | ExtSlice(slice* dims)
          | Index(expr value)

    boolop = And | Or

    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift
                 | RShift | BitOr | BitXor | BitAnd | FloorDiv

    unaryop = Invert | Not | UAdd | USub

    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn

    comprehension = (expr target, expr iter, expr* ifs, int is_async)

    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)
                    attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,
                 expr* kw_defaults, arg? kwarg, expr* defaults)

    arg = (identifier arg, expr? annotation, string? type_comment)
           attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    -- keyword arguments supplied to call (NULL identifier for **kwargs)
    keyword = (identifier? arg, expr value)

    -- import name with optional &#39;as&#39; alias.
    alias = (identifier name, identifier? asname)

    withitem = (expr context_expr, expr? optional_vars)

    type_ignore = TypeIgnore(int lineno, string tag)
}
</pre></div>
</div>
</section>
<section id="ast-helpers">
<h2><a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 中的辅助函数<a class="headerlink" href="#ast-helpers" title="永久链接至标题">¶</a></h2>
<p>除了节点类， <a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 模块里为遍历抽象语法树定义了这些工具函数和类:</p>
<dl class="function">
<dt id="ast.parse">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">parse</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">filename='&lt;unknown&gt;'</em>, <em class="sig-param">mode='exec'</em>, <em class="sig-param">*</em>, <em class="sig-param">type_comments=False</em>, <em class="sig-param">feature_version=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.parse" title="永久链接至目标">¶</a></dt>
<dd><p>把源码解析为AST节点。和 <code class="docutils literal notranslate"><span class="pre">compile(source,</span> <span class="pre">filename,</span> <span class="pre">mode,ast.PyCF_ONLY_AST)</span></code> 等价。</p>
<p>如果给出 <code class="docutils literal notranslate"><span class="pre">type_comments=True</span></code>，解析器会被修改以检查并返回 <span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> 和 <span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> 所描述的类型注释。 这相当于将 <code class="xref py py-data docutils literal notranslate"><span class="pre">ast.PyCF_TYPE_COMMENTS</span></code> 添加到传给 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 的旗标中。 这将报告针对未在正确放置类型注释的语法错误。 没有这个旗标，类型注释将被忽略，而指定 AST 节点上的  <code class="docutils literal notranslate"><span class="pre">type_comment</span></code> 字段将总是为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 此外，<code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">type:</span> <span class="pre">ignore</span></code> 注释的位置将作为 <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> 的 <code class="docutils literal notranslate"><span class="pre">type_ignores</span></code> 属性被返回（在其他情况下则总是为空列表）。</p>
<p>并且，如果 <code class="docutils literal notranslate"><span class="pre">mode</span></code> 为 <code class="docutils literal notranslate"><span class="pre">'func_type'</span></code>，则输入语法会进行与 <span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> &quot;签名类型注释&quot; 对应的修改，例如 <code class="docutils literal notranslate"><span class="pre">(str,</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">List[str]</span></code>。</p>
<p>此外，将 <code class="docutils literal notranslate"><span class="pre">feature_version</span></code> 设为元组 <code class="docutils literal notranslate"><span class="pre">(major,</span> <span class="pre">minor)</span></code> 将会尝试使用该will attempt to parse using that Python 版本的语法来进行解析。 目前 <code class="docutils literal notranslate"><span class="pre">major</span></code> 必须等于 <code class="docutils literal notranslate"><span class="pre">3</span></code>。 例如，设置 <code class="docutils literal notranslate"><span class="pre">feature_version=(3,</span> <span class="pre">4)</span></code> 将允许使用 <code class="docutils literal notranslate"><span class="pre">async</span></code> 和 <code class="docutils literal notranslate"><span class="pre">await</span></code> 作为变量名。 最低受支持版本为 <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code>；最高则为 <code class="docutils literal notranslate"><span class="pre">sys.version_info[0:2]</span></code>。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>足够复杂或是巨大的字符串可能导致Python解释器的崩溃，因为Python的AST编译器是有栈深限制的。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>增加了 <code class="docutils literal notranslate"><span class="pre">type_comments</span></code>, <code class="docutils literal notranslate"><span class="pre">mode='func_type'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">feature_version</span></code>。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.literal_eval">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">literal_eval</code><span class="sig-paren">(</span><em class="sig-param">node_or_string</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.literal_eval" title="永久链接至目标">¶</a></dt>
<dd><p>对表达式节点以及包含Python字面量或容器的字符串进行安全的求值。传入的字符串或者节点里可能只包含下列的Python字面量结构: 字符串，字节对象(bytes)，数值，元组，列表，字典，集合，布尔值和 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>这可被用于安全地对包含不受信任来源的 Python 值的字符串进行求值而不必解析这些值本身。 它并不能对任意的复杂表达式进行求值，例如涉及运算符或索引操作的表达式。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>足够复杂或是巨大的字符串可能导致Python解释器的崩溃，因为Python的AST编译器是有栈深限制的。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>目前支持字节和集合。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.get_docstring">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">get_docstring</code><span class="sig-paren">(</span><em class="sig-param">node</em>, <em class="sig-param">clean=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.get_docstring" title="永久链接至目标">¶</a></dt>
<dd><p>返回给定 <em>node</em> (必须为 <code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionDef</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncFunctionDef</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ClassDef</span></code> 或 <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> 节点) 的文档字符串，或者如果没有文档字符串则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 如果 <em>clean</em> 为真值，则通过 <a class="reference internal" href="inspect.html#inspect.cleandoc" title="inspect.cleandoc"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.cleandoc()</span></code></a> 清除文档字符串的缩进。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>目前支持 <code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncFunctionDef</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.get_source_segment">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">get_source_segment</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">node</em>, <em class="sig-param">*</em>, <em class="sig-param">padded=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.get_source_segment" title="永久链接至目标">¶</a></dt>
<dd><p>获取生成 <em>node</em> 的 <em>source</em> 的源代码段。 如果丢失了某些位置信息 (<code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_lineno</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code> 或 <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_col_offset</span></code>)，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>如果 <em>padded</em> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则多行语句的第一行将以与其初始位置相匹配的空格填充。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.fix_missing_locations">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">fix_missing_locations</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.fix_missing_locations" title="永久链接至目标">¶</a></dt>
<dd><p>当你通过 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 来编译节点树时，编译器会准备接受每个支持 <code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code> 属性的节点的相应信息。 对已生成节点来说这是相当繁琐的，因此这个辅助工具会递归地为尚未设置这些属性的节点添加它们，具体做法是将其设为父节点的对应值。 它将从 <em>node</em> 开始递归地执行。</p>
</dd></dl>

<dl class="function">
<dt id="ast.increment_lineno">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">increment_lineno</code><span class="sig-paren">(</span><em class="sig-param">node</em>, <em class="sig-param">n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.increment_lineno" title="永久链接至目标">¶</a></dt>
<dd><p>从 <em>node</em> 开始按 <em>n</em> 递增节点树中每个节点的行号和结束行号。 这在“移动代码”到文件中的不同位置时很有用处。</p>
</dd></dl>

<dl class="function">
<dt id="ast.copy_location">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">copy_location</code><span class="sig-paren">(</span><em class="sig-param">new_node</em>, <em class="sig-param">old_node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.copy_location" title="永久链接至目标">¶</a></dt>
<dd><p>在可能的情况下将源位置 (<code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_lineno</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_col_offset</span></code>) 从 <em>old_node</em> 拷贝到 <em>new_node</em>，并返回 <em>new_node</em>。</p>
</dd></dl>

<dl class="function">
<dt id="ast.iter_fields">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">iter_fields</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.iter_fields" title="永久链接至目标">¶</a></dt>
<dd><p>针对于 <em>node</em> 上在 <code class="docutils literal notranslate"><span class="pre">node._fields</span></code> 中出现的每个字段产生一个 <code class="docutils literal notranslate"><span class="pre">(fieldname,</span> <span class="pre">value)</span></code> 元组。</p>
</dd></dl>

<dl class="function">
<dt id="ast.iter_child_nodes">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">iter_child_nodes</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.iter_child_nodes" title="永久链接至目标">¶</a></dt>
<dd><p>产生 <em>node</em> 所有的直接子节点，也就是说，所有为节点的字段所有为节点列表的字段条目。</p>
</dd></dl>

<dl class="function">
<dt id="ast.walk">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">walk</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.walk" title="永久链接至目标">¶</a></dt>
<dd><p>递归地产生节点树中从 <em>node</em> 开始（包括 <em>node</em> 本身）的所有下级节点，没有确定的排序方式。 这在你仅想要原地修改节点而不关心具体上下文时很有用处。</p>
</dd></dl>

<dl class="class">
<dt id="ast.NodeVisitor">
<em class="property">class </em><code class="sig-prename descclassname">ast.</code><code class="sig-name descname">NodeVisitor</code><a class="headerlink" href="#ast.NodeVisitor" title="永久链接至目标">¶</a></dt>
<dd><p>一个遍历抽象语法树并针对所找到的每个节点调用访问器函数的节点访问器基类。 该函数可能会返回一个由 <a class="reference internal" href="#ast.NodeVisitor.visit" title="ast.NodeVisitor.visit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">visit()</span></code></a> 方法所提供的值。</p>
<p>这个类应当被子类化，并由子类来添加访问器方法。</p>
<dl class="method">
<dt id="ast.NodeVisitor.visit">
<code class="sig-name descname">visit</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.NodeVisitor.visit" title="永久链接至目标">¶</a></dt>
<dd><p>访问一个节点。 默认实现会调用名为 <code class="samp docutils literal notranslate"><span class="pre">self.visit_</span><em><span class="pre">classname</span></em></code> 的方法其中 <em>classname</em> 为节点类的名称，或者如果该方法不存在则为 <a class="reference internal" href="#ast.NodeVisitor.generic_visit" title="ast.NodeVisitor.generic_visit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generic_visit()</span></code></a>。</p>
</dd></dl>

<dl class="method">
<dt id="ast.NodeVisitor.generic_visit">
<code class="sig-name descname">generic_visit</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.NodeVisitor.generic_visit" title="永久链接至目标">¶</a></dt>
<dd><p>该访问器会在节点的所有子节点上调用 <a class="reference internal" href="#ast.NodeVisitor.visit" title="ast.NodeVisitor.visit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">visit()</span></code></a>。</p>
<p>请注意所有包含自定义访问器方法的节点的子节点将不会被访问除非访问器调用了 <a class="reference internal" href="#ast.NodeVisitor.generic_visit" title="ast.NodeVisitor.generic_visit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generic_visit()</span></code></a> 或是自行访问它们。</p>
</dd></dl>

<p>如果你想在遍历期间应用对节点的修改则请不要使用 <a class="reference internal" href="#ast.NodeVisitor" title="ast.NodeVisitor"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeVisitor</span></code></a>。 对此目的可使用一个允许修改的特殊访问器 (<a class="reference internal" href="#ast.NodeTransformer" title="ast.NodeTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeTransformer</span></code></a>)。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.8 版后已移除: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Num()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Str()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Bytes()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_NameConstant()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Ellipsis()</span></code> 等方法现在已被弃用且在未来的 Python 版本中将不会再被调用。 请添加 <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Constant()</span></code> 方法来处理所有常量节点。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="ast.NodeTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ast.</code><code class="sig-name descname">NodeTransformer</code><a class="headerlink" href="#ast.NodeTransformer" title="永久链接至目标">¶</a></dt>
<dd><p>子类 <a class="reference internal" href="#ast.NodeVisitor" title="ast.NodeVisitor"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeVisitor</span></code></a>  用于遍历抽象语法树，并允许修改节点。</p>
<p><a class="reference internal" href="#ast.NodeTransformer" title="ast.NodeTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeTransformer</span></code></a> 将遍历抽象语法树并使用visitor方法的返回值去替换或移除旧节点。如果visitor方法的返回值为 <code class="docutils literal notranslate"><span class="pre">None</span></code> , 则该节点将从其位置移除，否则将替换为返回值。当返回值是原始节点时，无需替换。</p>
<p>如下是一个转换器示例，它将所有出现的名称 (<code class="docutils literal notranslate"><span class="pre">foo</span></code>) 重写为 <code class="docutils literal notranslate"><span class="pre">data['foo']</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RewriteName</span><span class="p">(</span><span class="n">NodeTransformer</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">visit_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Subscript</span><span class="p">(</span>
            <span class="n">value</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span>
            <span class="nb">slice</span><span class="o">=</span><span class="n">Index</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">Constant</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)),</span>
            <span class="n">ctx</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>请记住，如果您正在操作的节点具有子节点，则必须先转换其子节点或为该节点调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">generic_visit()</span></code>  方法。</p>
<p>对于属于语句集合（适用于所有语句节点）的节点，访问者还可以返回节点列表而不仅仅是单个节点。</p>
<p>如果 <a class="reference internal" href="#ast.NodeTransformer" title="ast.NodeTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeTransformer</span></code></a> 引入了新的（不属于原节点树一部分的）节点而没有给出它们的位置信息（如 <code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code> 等），则应当调用 <a class="reference internal" href="#ast.fix_missing_locations" title="ast.fix_missing_locations"><code class="xref py py-func docutils literal notranslate"><span class="pre">fix_missing_locations()</span></code></a> 并传入新的子节点树来重新计算位置信息:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;eval&#39;</span><span class="p">)</span>
<span class="n">new_tree</span> <span class="o">=</span> <span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">RewriteName</span><span class="p">()</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
</pre></div>
</div>
<p>通常你可以像这样使用转换器:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">node</span> <span class="o">=</span> <span class="n">YourTransformer</span><span class="p">()</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.dump">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param">node</em>, <em class="sig-param">annotate_fields=True</em>, <em class="sig-param">include_attributes=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.dump" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>node</em> 中树结构的格式化转储。 这主要适用于调试目的。 如果 <em>annotate_fields</em> 为真值（默认），返回的字符串将显示字段的名称和值。 如果 <em>annotate_fields</em> 为假值，结果字符串将通过省略无歧义的字段名称变得更为紧凑。 默认情况下不会转储行号和列偏移等属性。 如果需要，可将 <em>include_attributes</em> 设为真值。</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference external" href="https://greentreesnakes.readthedocs.io/">Green Tree Snakes</a>，一个外部文档资源，包含处理 Python AST 的完整细节。</p>
<p><a class="reference external" href="https://asttokens.readthedocs.io/en/latest/user-guide.html">ASTTokens</a> 会为 Python AST 标注生成它们的源代码中的形符和文本的位置。 这对执行源代码转换的工具很有帮助。</p>
<p><a class="reference external" href="http://leoeditor.com/appendices.html#leoast-py">leoAst.py</a> 通过在形符和 ast 节点之间插入双向链接统一了 Python 程序基于形符的和基于解析树的视图。</p>
<p><a class="reference external" href="https://libcst.readthedocs.io/">LibCST</a> 将代码解析为一个实体语法树（Concrete Syntax Tree），它看起来像是 ast 树而又保留了所有格式化细节。 它对构建自动化重构（codemod）应用和代码质量检查工具很有用处。</p>
<p><a class="reference external" href="https://parso.readthedocs.io">Parso</a> 是一个支持错误恢复和不同 Python 版本的（在多个 Python 版本中）往返解析的 Python 解析器。 Parso 还能列出你的 Python 文件中的许多错误。</p>
</div>
</section>
</section>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code> --- 抽象语法树</a><ul>
<li><a class="reference internal" href="#node-classes">节点类</a></li>
<li><a class="reference internal" href="#abstract-grammar">抽象文法</a></li>
<li><a class="reference internal" href="#ast-helpers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code> 中的辅助函数</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="parser.html"
                        title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code> --- 访问 Python 解析树</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="symtable.html"
                        title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symtable</span></code> ——访问编译器的符号表</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/library/ast.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="symtable.html" title="symtable ——访问编译器的符号表"
             >下一页</a> |</li>
        <li class="right" >
          <a href="parser.html" title="parser --- 访问 Python 解析树"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.8.16 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="language.html" >Python 语言服务</a> &#187;</li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 2月 09, 2023.
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>

  </body>
</html>