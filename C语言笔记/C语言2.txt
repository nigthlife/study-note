		  	
			  	第八次课  二维数组

设置VS显示代码行数,可以方便调试代码，工具-》选项-》文本编辑器-》C/C+±》常规-》行号勾选上

1.二维数组的定义
      类型名 数组名1[EXP1][EXP2],数组名2[EXP1][EXP2],...;
EXP1:行下标
 EXP2:列下标

2.计算二维数组

总字节数 = sizeof(数组类型)*行数*列数
int a[2][3];//数组a占据的字节数：4*2*3=24字节 
计算元素a[i][j]在数组中位置的公式(从0开始计数)：i*m+j（m为数组的列数)，如：a[1][2]是在数组a中的第1*3+2=5位

3..二维数组的初始化方法有哪些？
1.按行全部赋初值   
2.按存储顺序全部赋初值   
3.部分赋初值（按存储顺序）
4.部分赋初值（按行部分赋值）
5.省略行数赋初值：定义时可省略行数！

		第九次课 结构体

1.typedef struct 结构体名称 变量名

1=0001
2=0010
3=0011
4=0100
5=0101
6=0110
7=0111
8=1000
9=1001
A=1010
B=1011
C=1100
D=1101
E=1110
F=1111
16进制输出是 %#X   long int 是%Ld输出  

			      第十次课   文件指针

1.：
	#include<stdlib.h> 文件操作函数用到
2.：
	file *f    定义文件类型指针，它就是一个结构体，指向的是一个文件的	地址
3.：
	使用fopen函数打开一个文件
	  FILE *fopen(const char *path, const char *mode);
	 @path     要打开的文件名(可以包含路径) ，是一个字符串  
	 @mode     打开模式(字符串)
4.：	
	f=fopen（“文件路径，使用斜杠或者使用双斜杠
	（这个是绝对路径死的）”
	“打开权限模式”）
5.：
	返回值：成功返回file指针，失败返回null
6.：
	if(f == null)
	printf("文件打开失败\n");
   	else
	printf("文档打开成功");
	fclose(f)//关闭文件

7.：
	第二种方式打开文档：要求文件与main.c在同一个目录下
8.：
	从文件中读出一个字符使用fgetc函数：先定义一个char ch = 0
	ch = fgetc（f）；//，，默认读第一个字符
	int fgetc(FILE *stream);
	 @stream 指定的文件指针
（8）：
	feof();
  	ferror();
	 int feof(FILE *stream);//如果对应的文件数据到达文件结尾(eof)，则该函数的返回值为非0值
	int ferror(FILE *stream); //如果对应的文件数据出错，则该函数的返回值为非0值
   	 写:（往指定文件中写入一个字符）

（9）：
	往文件中写入一个字符
	fputc（‘输入写入的字符’“文件指针”）
	成功 写入的字符对应的ASCII码
	失败 返回-1（eof）
	 int fputc(int c, FILE *stream);
	 @c  要输出的字符
                 @stream 指定的输出文件对应的文件指针
	 int fputs(const char *s, FILE *stream); // 将s指定的字符串输出到stream 指定的文件中
       	 fputs 不会将'\0'进行输出，遇到'\0'就输出

（10）;
	循环输出字符
	while（！feof（f））//feof函数，读到文件结束标志返回-1否则返回	0
	{
	      pirntf("读出的字符是%c",ch);
	      ch = fgetc(f);
	}
（10）：
	*****获取字符串******
	fgets
                char *fgets(char *s, int size, FILE *stream);
	@s    自己开辟的一块内存空间的首地址(用来保存获取到数据)
                @size 一次fgets操作期望读取到的最大字符个数
                @stream 指定的输入文件的文件指针

（11）:
	往文件中写入数据
	fwrite（写入数据的地址，sizeof（变量名），写入几块数据，文件指针）

（12）:
	读文件中的数据
	 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
      	 size_t fwrite(const void *ptr, size_t size, size_t nmemb,FILE *stream);
	@ptr	保存数据的内存空间首地址
	@size	单个对象的大小	sizeof（对象类型）
	@nmemb		一次期望操作的对象个数
	@stream		要操作的流文件
	

（13）:
	fseek文件定位函数（设置光标函数）定位读写光标
	SEEK_SET  移动到最开头位置
	SEEK_END 移动到最末尾的位置
	乘以 的数字有正负之分：为正往后偏移，为负往前偏移
	fdeek（要定位的文件指针，偏移值，相对的偏移起点）
	fseek（f,0,SEEK_SET）//光标移动到文件开头往后偏移0个字节的位	置
	要输出第二块数据fseek（f,2*sizeof（变量名）,SEEK_SET）
	//2*偏移到第二个末尾
（14）：
	r：只读，为了输入数据，打开一个已存在的文本文件
	w：只写，为了输出数据，打开一个文本文件
	a：追加，向文本文件尾添加数据
	rb：只读，为了输入数据，打开一个二进制文件
	wb：只写，为了输出数据，打开一个二进制文件
	ab：追加，向二进制文件尾添加数据
	“r+”：读写，为了读和写，打开一个文本文件
	“w+”：读写，为了读和写，建立一个新的文本文件
	“a+”：读写，为了读和写，打开一个文本文件
	“rb+”：读写，为了读和写，打开一个二进制文件
	“wb+”：读写，为了读和写，建立一个新的二进制文件
	“ab+”：读写，为读写打开一个二进制文件
（15）：
	fgetc（指定的文件指针）：从文件中读取一个字符
	成功返回对应字符是ASCII码值，失败EOF（文件结束）error 返回-1

			第六次课    字符串
			字符串两端用双引号引起来
（1）:
	使用时应该添加  include<string.h>
	strlen（""）求字符长度
	并不会把‘\0’算入字节数内，只计算'\0'之前的所有字符个数
	
（2）字符串：由一对双引号括起来的0个或多个字符组成
（3）putchar(char类型变量)  //单个字符输出函数，只能输出单个字符
（4）puts（数组名）//多个字符输出函数，会自动换行，只能输出字符串
（5）getchar（不放参数） //单个字符输入函数  只接收字符
（6）gets（数组名）  //字符串的输入函数  能输入带空格的字符串，可以获取上一个scanf的回车字符
（7）scanf(%s) 字符串输入不能带空格，带了空格后空格之后的数据都会不见了
（8）scanf和gets套用时得在他们中间放一个getchar（）；函数，用于吃掉scanf遗留的回车字符
（9）字符串出来必须用到string.h
（10）strcpy（目标字符串地址。原字符串地址）
	strcpy（a,b）把字符串b复制给a
（11）字符串连接函数：
	strcat（目标字符串地址。原字符串地址）
	strcat（a，b）这是把b的字符内容连接到a上，b本身不变
	连接是从a的反斜杠的位置开始连接一个一个放在a的后面，
	目标函数也要足够长，能够存下连接后的数据
（12）字符串比较函数：
	int s = strcmp（a，b）需要定义一个接收函数
	当a=b 返回一个0
	当a<b 返回负数
	当a>b 返回正数
（！！）：char * scmp(char*a,char *b)
{
	if(strcmp(a,b)<0) return(a)
	else return(b)
}	
	比较字符串函数：
	strcmp函数：
	strcmp（a，b）比较a，b的 大小，
	如果a<b  返回a的值
	如果a>b  返回b的值
（13）用strcmp比较中文
	gets（a）输入中文
	if(strcmp(a,"男" == 0))  判断a的内容是否为男，如果为男，返回0，不是男就什么都木有
	if(strcmp(a,"女" == 0))  判断a的内容是否为女，如果为女，返回0，不是女就什么都木有
（14）：用反斜杠开头后面跟一个字母代表一个控制字符，
	用： \\代表字符\
	用：\’代表撇号字符
	'\ddd'用：反斜杠后面跟1到3个八进制数代表ASCII码为八进制数的字符
	'\xhh'用：\x后面跟1到2个十六进制数代表ASCII码为该十六进制的字符
（15）：
	C语言中，字符型数据和整型数据之间可以通用，
	一个字符型数据既可以以字符形式输出，也可以以整数形式输出，
（16）：
	scanf（）赋值语句它会接收回车字符
（17）：
	字符型常量只能用单引号括起来，不能用双引号括起来
（18）：
	反斜杠后直接跟数字表示八进制
	反斜杠后用小写字母x开头来表示十六进制
	
（19）：
	1.字符型常量只能包含一个字符
	2.字符串常量是由一对双引号括起来的字符序列
	3.C语言里木有字符串类型的常量和变量，
	但是可以通过定义字符型数组或者指针来得到字符串
（20）：
	对于字符的比较，不可以用关系运算符，而只能用字符串比较函数	strcmp()比较
	无任何字符的字符串叫空串，用“”表示，
	空串的长度是零，它小于一切非空字符串
（21）：
	%a,%A：读入一个浮点值
	%c：读入一个字符
	%d：读入一个十进制数
	%i ：读入十进制，八进制，十六进制整数
	%o：读入八进制整数
	%x,%X：读入一个十六进制整数
	%s：读入一个字符串，遇空格，制表符或换行结束
	%f,%F,%e,%E,%g,%G 用来输入实数，可以用小数形式或指数形式输入。
	%p 读入一个指针	
	%u 读入一个无符号十进制整数
	%n 至此已读入值的等价字符数
	%[] 扫描字符集合
	%% 读%符号



			第七次课 内存管理

（1）主要有：常量区、代码区、栈区、堆区、静态区static
	2.常量区--用来存放常量的
	开辟内存时间:编译的时候
	销毁内存时间:程序结束后系统释放


（2）函数指针：
	//定义了一个函数指针p，可以存放函数的地址
	//可以存放返回值类型为void，形参为void的函数,否则会有警告
	void（*p）(void)  //该变量是一个指针变量，占据4个字节都占据4个字节
	p = fun1  //指向函数fun的入口地地址
	p有俩种方法调用函数。
	第一种是：p();    
	第二种是：(*p)();
	void(*q)(int x);

（3）函数指针数组：
	/相当于定义了3个函数指针变量
	void（*pf[3]）(void)
调用方式：pf[0]();

（4）堆区：malloc 不会自动化初始化为0，没有初值
	：calloc 会自动初始化为0
	int * p
	必须在<stdib.h>使用
	if(p == null)   p等于空后无法申请到堆内存，里面的数据是未知的，不会赋初值
	p = （int *）malloc（4）（强制转换类型）malloc(需要的字节数); 
	因为void * 是个通用指针，并不确定他占几个字节，所以进行强制转换
      	free（p）;  //释放p指向的堆内存，释放后p就变成野指针
	
	//申请了一快长度为5，每个为4个字节的堆内存，里面数据初值为0
	p = (int *)calloc(5,sizeof(int))
	free（p）; 释放（销毁）的时候不能进行指针偏移 
（5）auto(自动变量)：凡是非静态的局部变量--自动变量
	1. auto 可以省略
	2.全局变量不可以使用auto修饰
	3.函数的形式参数存储类别--auto
	4.凡是auto变量---栈变量---栈区

（6）static（静态变量）
	静态变量:用static 修改是变量(局部的也可以是全局) 
	      开辟内存的时间:在编译程序的时候
	      销毁内存的时间:主函数结束的时候
	      只会执行一-次，如果没有赋初始值，默认为0
	static 修饰全局变量
	      这个全局变量只能在本文件中使
	'static 还可以修饰函数
	      这个函数只能在本文件中使用


（7）extern（外部变量） 
	extern :扩展外部变量的作用域
	用法:就是其他文件中的变量的声明放在本文件中，前面加上extern

（8）register（寄存器变量）
	register:
	如果是变量经常被使用，我们就可以用register

（9）堆区: 堆区的内存是由程序员手动申请的
	堆区申请内存的 函数：malloc  calloc

          malloc：
	开辟的时间就是你手动申请的时间
	释放的时间就是你调用free
	//在堆区申请内存，内存大小由参数决定
	//返回在堆区申请好的内存空间的首地址
	//返回值类型: void *---强制转换
	int *p = (int *) malloc(sizeof(int)) ;
	malloc申请内存空间之后不会给你做初始化，输出的是地址
          calloc：
	相当于申请的是一个数字形式的空间
	int *p = (int *) calloc(sizeof(int)) ;
	calloc会初始化申请内存空间，默认为0











